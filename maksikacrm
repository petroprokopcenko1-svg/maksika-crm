from typing import Optional
from datetime import datetime, timedelta

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlmodel import SQLModel, Field, Session, create_engine, select
from passlib.context import CryptContext
from jose import jwt, JWTError

app = FastAPI(
    title="–ú–∞–∫—Å—ñ–∫–∞ CRM",
    version="0.1.0"
)


# ---------------- DB ----------------
DB_URL = "sqlite:///./db.sqlite3"
engine = create_engine(DB_URL, echo=False)


# ---------------- Security ----------------
SECRET_KEY = "change_me"          # –∑–∞–º—ñ–Ω–∏ –Ω–∞ –≤–∏–ø–∞–¥–∫–æ–≤–∏–π —Ä—è–¥–æ–∫
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24  # 1 –¥–µ–Ω—å
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")  # –ø–æ–∫–∞–∑—É—î –∫–Ω–æ–ø–∫—É Authorize —É Swagger


# ---------------- Models ----------------
class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(index=True, unique=True)
    hashed_password: str


class Offer(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    geo: str
    price: float


class Lead(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    phone: str
    geo: str
    offer_id: int = Field(foreign_key="offer.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)


# ---------------- Schemas ----------------
from pydantic import BaseModel


class LoginData(BaseModel):
    email: str
    password: str


class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"


# ---------------- Helpers ----------------
def create_db_and_seed():
    SQLModel.metadata.create_all(engine)
    with Session(engine) as s:
        # seed admin
        existing = s.exec(select(User).where(User.email == "admin@local")).first()
        if not existing:
            admin = User(email="admin@local", hashed_password=pwd_context.hash("admin123"))
            s.add(admin)
            s.commit()


def authenticate(email: str, password: str) -> Optional[User]:
    with Session(engine) as s:
        user = s.exec(select(User).where(User.email == email)).first()
        if not user:
            return None
        if not pwd_context.verify(password, user.hashed_password):
            return None
        return user


def create_token(sub_email: str) -> str:
    payload = {"sub": sub_email, "exp": datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
        with Session(engine) as s:
            user = s.exec(select(User).where(User.email == email)).first()
            if not user:
                raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
            return user
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token error")


# ---------------- Startup ----------------
@app.on_event("startup")
def on_startup():
    create_db_and_seed()


# ---------------- Routes ----------------
@app.get("/health", tags=["default"])
def health():
    return {"status": "ok"}


# ---- AUTH ----
@app.post("/auth/login", response_model=TokenOut, tags=["auth"])
def login(data: LoginData):
    user = authenticate(data.email, data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    token = create_token(user.email)
    return {"access_token": token, "token_type": "bearer"}


# ---- OFFERS ----
@app.post("/offers", tags=["offers"])
def create_offer(offer: Offer, _: User = Depends(get_current_user)):
    with Session(engine) as s:
        s.add(offer)
        s.commit()
        s.refresh(offer)
        return offer


@app.get("/offers", tags=["offers"])
def list_offers(_: User = Depends(get_current_user)):
    with Session(engine) as s:
        return s.exec(select(Offer)).all()


# ---- LEADS ----
@app.post("/leads", tags=["leads"])
def create_lead(lead: Lead, _: User = Depends(get_current_user)):
    with Session(engine) as s:
        s.add(lead)
        s.commit()
        s.refresh(lead)
        return lead


@app.get("/leads", tags=["leads"])
def list_leads(_: User = Depends(get_current_user)):
    with Session(engine) as s:
        return s.exec(select(Lead)).all()

# üöÄ Ethical CRM (FastAPI) ‚Äî Full

## –Ø–∫ –∑–∞–ø—É—Å—Ç–∏—Ç–∏
1) –ê–∫—Ç–∏–≤—É–π —Å–µ—Ä–µ–¥–æ–≤–∏—â–µ (Windows cmd):
```
venv\Scripts\activate.bat
```
2) –í—Å—Ç–∞–Ω–æ–≤–∏ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ (—Ä–∞–∑–æ–≤–æ):
```
pip install -r requirements.txt
```
3) –ó–∞–ø—É—Å–∫:
```
uvicorn main:app --reload --port 4000
```
4) –í—ñ–¥–∫—Ä–∏–π: http://127.0.0.1:4000/docs

## –Ø–∫ –∞–≤—Ç–æ—Ä–∏–∑—É–≤–∞—Ç–∏—Å—å —É Swagger
- –í—ñ–¥–∫—Ä–∏–π **POST /auth/login** ‚Üí **Try it out** ‚Üí —Ç—ñ–ª–æ:
```json
{
  "email": "admin@local",
  "password": "admin123"
}
```
- –°–∫–æ–ø—ñ—é–π `access_token` –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.
- –£–≥–æ—Ä—ñ –Ω–∞—Ç–∏—Å–Ω–∏ **Authorize** ‚Üí —É –ø–æ–ª—ñ *OAuth2PasswordBearer* –≤—Å—Ç–∞–≤ —Ç–æ–∫–µ–Ω (–±–µ–∑ —Å–ª–æ–≤–∞ `Bearer`).
- –¢–µ–ø–µ—Ä –µ–Ω–¥–ø–æ—ñ–Ω—Ç–∏ `/offers` —ñ `/leads` –±—É–¥—É—Ç—å –ø—Ä–∞—Ü—é–≤–∞—Ç–∏.

fastapi
uvicorn
sqlmodel
passlib[bcrypt]
python-jose
